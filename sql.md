##聚簇索引和非聚簇索引
MySQL中最常见的两种存储引擎分别是MyISAM和InnoDB，分别实现了非聚簇索引和聚簇索引。

非聚簇索引

    聚簇索引（InnoDB）的解释是: 聚簇索引的顺序就是数据的物理存储顺序
    非聚簇索引（MyISAM）的解释是: 索引顺序与数据物理排列顺序无关

##事务隔离级别  

###并发操作问题：
    脏读：指当A事务正在访问对数据正在修改中，还没有提交到数据库中，另外的事务B读取到了中间修改中的错误数据。
    不可重复读：指在A事务内，多次读同一数据。在这个事务还没有执行结束，B事务则修改同一数据，导致A俩次读取出现不一样的结果。
    幻象读：一个事务先后读取一个范围的记录，但两次读取的纪录数量不同，我们称之为幻象读。
    因为行锁只能锁住行，即使把所有的行记录都上锁，也阻止不了新插入的记录。
###隔离级别：
ANSI/ISO SQL定义的标准隔离级别有四种，从高到底依次为：可序列化(Serializable)、可重复读(Repeatable Reads)、提交读(Read Committed)、未提交读(Read Uncommitted)。

    · 读未提交 （Read uncommitted）：一个事务可以读取另一个未提交事务的数据。 会导致“脏读”、“不可重复读”、“幻读”。
    
    · 读提交（Read Committed）：只能读到已经提交了的内容。SQL Server和Oracle的默认隔离级别。
    若有事务对数据进行更新（UPDATE）操作时，读操作事务要等待这个更新操作事务提交后才能读取数据，可以解决脏读问题。但在这个事例中，出现了一个事务范围内两个相同的查询却返回了不同数据，这就是不可重复读。
    读没有加锁，这种既能保证一致性又不加锁的读也被称为“快照读（Snapshot Read）”。
    
    · 可重复读(Repeated Read)：MySql的默认隔离级别。重复读可以解决不可重复读问题。
    事务开启，不允许其他事务的UPDATE修改操作。但是还会有幻读问题。因为幻读问题对应的是插入INSERT操作，而不是UPDATE操作。
    如：A事务有俩次读取列表数据，在第二次前，B插入了一条数据，则A的第二次拉列表数据多了1条.
    
    · 串行读：事务“串行化顺序执行”，就是排队执行。“脏读”、“不可重复读”、“幻读”都可以被避免，执行效率奇差，性能开销最大，所以基本没人会用。


MySQL对这四种隔离级别是都支持的。但是Oracle数据库只支持Serializable和Read Committed。  
    (Oracle其实还支持Read-Only，不允许用户修改数据，基本没用)
###默认隔离级别
Oracle默认的隔离级别是 RC，而MySQL默认的隔离级别是 RR。  
MySQL默认隔离级别RR的原因：


    MySQL在主从复制的过程中，数据的同步是通过bin log进行的，把数据变更记录到bin log中，再从bin log中恢复数据。
    MySQL的bin log主要支持三种格式，分别是statement(早)、row以及mixed。
    当binlog的格式为statemen时，binlog 里面记录的就是 SQL 语句的原文。
    sql回放时，在RC隔离级别下，会可能造成顺序不对导致的数据错误。


