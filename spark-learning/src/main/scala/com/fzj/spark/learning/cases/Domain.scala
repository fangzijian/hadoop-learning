package com.fzj.spark.learning.cases

/**
 * 样例类是种特殊的类：
 *
 * 构造器的每个参数都成为val，除非显式被声明为var，但是并不推荐这么做；
 * 在伴生对象中提供了apply方法，所以可以不使用new关键字就可构建对象；
 * 提供unapply方法使‘模式匹配’可以工作；
 * 生成toString、equals、hashCode和copy方法，除非显示给出这些方法的定义。
 *
 */
case class Domain(id: Int, ID: Long, name: String, field: String)


并发操作问题：
脏读：指当A事务正在访问对数据正在修改中，还没有提交到数据库中，另外的事务B读取到了中间修改中的错误数据。
不可重复读：指在A事务内，多次读同一数据。在这个事务还没有执行结束，B事务则修改同一数据，导致A俩次读取出现不一样的结果。
幻象读：一个事务先后读取一个范围的记录，但两次读取的纪录数量不同，我们称之为幻象读。
因为行锁只能锁住行，即使把所有的行记录都上锁，也阻止不了新插入的记录。
隔离级别：
读未提交 （Read uncommitted）：一个事务可以读取另一个未提交事务的数据。 会导致“脏读”、“不可重复读”、“幻读”。
读提交（Read Committed）：只能读到已经提交了的内容。SQL Server和Oracle的默认隔离级别。
若有事务对数据进行更新（UPDATE）操作时，读操作事务要等待这个更新操作事务提交后才能读取数据，可以解决脏读问题。但在这个事例中，出现了一个事务范围内两个相同的查询却返回了不同数据，这就是不可重复读。
读没有加锁，这种既能保证一致性又不加锁的读也被称为“快照读（Snapshot Read）”。
可重复读(Repeated Read)：MySql的默认隔离级别。重复读可以解决不可重复读问题。
事务开启，不允许其他事务的UPDATE修改操作。但是还会有幻读问题。因为幻读问题对应的是插入INSERT操作，而不是UPDATE操作。
如：A事务有俩次读取列表数据，在第二次前，B插入了一条数据，则A的第二次拉列表数据多了1条.
串行读：事务“串行化顺序执行”，就是排队执行。“脏读”、“不可重复读”、“幻读”都可以被避免，执行效率奇差，性能开销最大，所以基本没人会用。